### C.Berry-Jam

本题是说，有2n个元素的binary array。让你从正中间开始，往左往右取若干个数，形成一段连续subarray，使得剩下的元素里0和1的数目一样。问最少需要取多少个数。

算法比较简单。首先，从第1个元素，到第n个元素，计算每个位置i处，前i个数里面零和一的数目之差，记录下```Map[diff]=i```.

然后，从第2n个数往前遍历，同样计算后缀累积的diff。比如第j个元素时，后面零和一的数目之差为diff，则查看Map里面是否有对应的-diff。假设Map[-diff]=i，那么从i+1到j-1就是一段合法的subarray，满足剩下的元素的总diff为零，即两种元素的数目相等。这样将所有的j遍历完之后，就可以搜索到最小长度的subarray。

时间复杂度是o(n)。
