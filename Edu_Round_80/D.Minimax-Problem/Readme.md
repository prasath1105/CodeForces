### D.Minimax-Problem

题意是说，有n个数组，每个数组都有m个元素。其中n很大，但是m很小。对于任意两个数组a[i]和数组b[i]，我们逐个元素取其两者之间较大的那个，得到一个新的数组称之为t[i]，再在t中的最小值元素定义为s。求所有的这样的s里面最大的那个，并把对应的两个数组的编号记录下来。

一种比较高效的算法就是二分搜索这个值。我们假设这个值是val，那么我们就希望至少能找到两个数组a,b，使得他们合并得到的数组t的最小值能够大于等于val。如果这个结论不成里，我们就要降低val的预期；否则我们可以尝试更大的val。

为了进一步高效地实现上面的想法，我们将所有的数组都逐个元素地与val比大小，转化为一个01数组（大于等于val的认为是1）。因为m很小，所以这个01数组又可以转化为一个二进制数。如果有两个数组对应的两个二进制编码的“位或”结果都是1的话，那么说明这两个数组“合并”之后的t的每一位都会大于val，那么自然t的最小值也一定大于等于val。

考虑到n可以很大，但实际上二进制的编码只有2^m种，说明这些数组经过与val的比较之后会生成很多重复的二进制。我们可以用一个集合过滤掉重复的编码，在剩下的编码里面枚举所有的pair会更高效。
