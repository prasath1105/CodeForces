### C.Two-Arrays

本题是说，有两个数组a和b，每个数组的元素都是n个，所有元素范围都是[1,m]。另外a是个非递减数组，b是个非递增数组。问这样的数组对(a,b)有多少种。

#### 解法1：
考虑两个数组的最后一个元素。如果a[m]=x的话，考虑a的组合有多少种可能？我们可以想到DP，令dp[i][x]表示截至第i位时，第i位上可以是x的数组a的组合数。显然，因为a是递增数组，有```dp[i][x] = dp[i-1][1]+dp[i-1][2]+...+dp[i-1][x]```。不难做到，我们可以用o(nm)的时间复杂度计算dp[m][x]。

回过头来看，如果a[m]=x，那么b[n]=y有什么选择呢？根据题意```x<=y<=m```。我们遍历所有的y的可能，同时发现从b[1]到b[n]必须是个递减数组，递减幅度是n-y+1。计算这样的数组b的组合数，其实计算给定递增幅度的数组a的组合数，方法完全一样。我们可以直接从上面的dp数组中调用dp[m][n-y-1]即可。

所以核心部分的代码就是：
```cpp
    int ret = 0;
    for (int x=1; x<=n; x++)
    {
        for (int y=i; y<=n; y++)
            ret = (ret+(dp[m][x]*dp[m][n-y+1])%MOD)%MOD;
    }
```    

#### 解法2：
如果将所有的数组元素如此排列：
```
a1,a2,a3,...,am,bm-1,...,b3,b2,b1
```
可以发现这就是一个（非严格）递增数组。每个元素的数值范围是[1,n]，需要取2m个元素。当然直接计算C(n,2m)是不对的，那么如何处理可以有重复元素呢？我们可以假想增加2m-1个数值称为dup放入候选池中，于是我们现在就是在{1,2,3..,n,dup_1,dup_2,...dup_2m-1}总共n+2m+1种数值中随机取出2m个元素的组合来。其中如果组合中包含了某个dup_i，那么定义元素dup_i代表的就是将这个组合中第i大的元素（也就是将该重复一遍）。比如{1,2,dup_1,dup_2}表示的就是{1,1,1,2}；{1,2,3,dup_2}表示的就是{1,2,2,3}；{1,dup_1,dup_2,dup_3}表示的就是{1,1,1,1}...注意，这些例子中我们取出四个数作为组合，那么肯定不会出现dup_4.

上面的方法可以得到取值范围是[1,n]的所有的（非严格）递增序列。也就是说，这样的序列总共有C(n+2m-1,2m)个。我们可以稍微简化一下组合数的公式：
```
ans = (n+2m-1)!/(2m)!/(n-1)! = (n+2m-1 * n+2m-2 * .. * n) / (2m * 2m-1 * ... *2 *1)
```
分子上可以将每个因式的模直接乘起来。因为2m并不大，对于分母，可以预算算好每个因式的逆元，即inv[i]，然后再逐个和分子的结果乘起来即可。
