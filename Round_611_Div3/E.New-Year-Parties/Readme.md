### E.New-Year-Parties

本题是说给一个数组。每个元素可以允许减一，加一，或者保持不变。问最后这个数组里存在不同的数字的个数最少可能是多少，最多可能是多少。

#### 解法1：DP

将这个数组排序。考虑到每个元素其实只有三种状态，所以动态规划是一种显然的思路。令dp[i][k]，其中i=0,1,..n，k=-1,0或者1，表示截至到第i个元素为止时，当第i个元素分别做-1,+0,+1操作后能得到的整个数组不同数字的最少个数。显然，对于任何的i，在dp[i][-1],dp[i][0],dp[i][1]三种之中，dp[i][-1]一定是最小的，dp[i][0]次之，dp[i][1]最大。

遍历全部的k。如果pos[i]+k等于pos[i-1]-1，那么我们肯定倾向于将第i-1个元素左移1，使得pos[i]+k与pos[i-1]-1重叠，这样对于第i个元素而言肯定是最优的方案。如果不满足，我们就查看pos[i]+k是否等于pos[i-1]；再不满足，查看pos[i]+k是否等于pos[i-1]+1。都不满足的话，第i个元素无论如何都无法与第i个元素重叠，那么dp[i][k]只能赋值为dp[i-1][1]+1。

对于第二问，重新设计dp[i][k]，其中i=0,1,..n，k=-1,0或者1，表示截至到第i个元素为止时，当第i个元素分别做-1,+0,+1操作后能得到的整个数组不同数字的最多的个数。显然，对于任何的i，在dp[i][-1],dp[i][0],dp[i][1]三种之中，dp[i][-1]一定是最小的，dp[i][0]次之，dp[i][1]最大。

遍历全部的k。如果pos[i]+k大于pos[i-1]+1，说明第i个元素无论如何与第i-1个元素都不重叠，那么我们肯定倾向于让第i-1个元素右移1，这样对于第i-1个元素而言肯定是最优的方案。如果不满足，我们就查看pos[i]+k是否等于pos[i-1]+1，是的话我们肯定倾向于第i-1个元素不动；再不满足，查看pos[i]+k是否等于pos[i-1]，使得花我们肯定倾向于第i-1个元素左移1。都不满足的话，pos[i]+k只能与pos[i-1]-1重合，此时只要dp[i][k]赋值为dp[i-1][-1]。

最终的答案应该分别是dp1[n-1][0]和dp2[n-1][2].

#### 解法2：贪心

设计一个min_last变量，表示截至到当前元素i为止，能够得到最少数目时我们会放置元素i的位置。

如果当前元素i的位置与min_last差在3以内，那么我们一定会让其重合，因此min_houses不变。否则的话，没办法，min_houses必须加一，于是我们就会让元素i右移，目的是让它有更多的机会与后面的元素重合。

设计一个max_last变量，表示截至到当前元素i为止，能够得到最多数目时我们会放置元素i的位置。

如果当前元素i的位置与max_last差在3之外，那么max_houses肯定能自增一，此外我们还一定会让元素i左移一，目的是让它有更多的机会与后面的元素不重合。而如果元素i的位置有机会与max_last重合的话，我们一定会让元素i尽量放置在max_last的后面一位，努力让max_houses能自增。否则，就意味着max_last与元素i右移的位置一直，注定会重合在一起。
