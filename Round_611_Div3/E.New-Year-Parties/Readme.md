### E.New-Year-Parties

本题是说给一个数组。每个元素可以允许减一，加一，或者保持不变。问最后这个数组里存在不同的数字的个数最少可能是多少，最多可能是多少。

将这个数组排序。考虑到每个元素其实只有三种状态，所以动态规划是一种显然的思路。令dp[i][k]，其中i=0,1,..n，k=-1,0或者1，表示截至到第i个元素为止时，当第i个元素分别做-1,+0,+1操作后能得到的整个数组不同数字的最少个数。显然，对于任何的i，在dp[i][-1],dp[i][0],dp[i][1]三种之中，dp[i][-1]一定是最小的，dp[i][0]次之，dp[i][1]最大。

遍历全部的k。如果pos[i]+k等于pos[i-1]-1，那么我们肯定倾向于将第i-1个元素左移1，使得pos[i]+k与pos[i-1]-1重叠，这样对于第i个元素而言肯定是最优的方案。如果不满足，我们就查看pos[i]+k是否等于pos[i-1]；再不满足，查看pos[i]+k是否等于pos[i-1]+1。都不满足的话，第i个元素无论如何都无法与第i个元素重叠，那么dp[i][k]只能赋值为dp[i-1][1]+1。

对于第二问，重新设计dp[i][k]，其中i=0,1,..n，k=-1,0或者1，表示截至到第i个元素为止时，当第i个元素分别做-1,+0,+1操作后能得到的整个数组不同数字的最多的个数。显然，对于任何的i，在dp[i][-1],dp[i][0],dp[i][1]三种之中，dp[i][-1]一定是最小的，dp[i][0]次之，dp[i][1]最大。

遍历全部的k。如果pos[i]+k大于pos[i-1]+1，说明第i个元素无论如何与第i-1个元素都不重叠，那么我们肯定倾向于让第i-1个元素右移1，这样对于第i-1个元素而言肯定是最优的方案。如果不满足，我们就查看pos[i]+k是否等于pos[i-1]+1，是的话我们肯定倾向于第i-1个元素不动；再不满足，查看pos[i]+k是否等于pos[i-1]，使得花我们肯定倾向于第i-1个元素左移1。都不满足的话，pos[i]+k只能与pos[i-1]-1重合，此时只要dp[i][k]赋值为dp[i-1][-1]。

最终的答案应该分别是dp1[n-1][0]和dp2[n-1][2].
