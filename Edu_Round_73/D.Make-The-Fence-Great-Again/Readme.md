### D.Make-The-Fence-Great-Again

本题是一个DP题，怎么看出来呢？关键在于要发现每块墙的操作方案就三种！加零块，加一块，加两块！就这三种方案，就一定能保证最后的总墙体都是“参差不齐”的。比如，如果前后相差0，自身就可以加1；如果前后相差1，自身就可以加2；如果前后相差2，自身就可以加1。

所以dp[i][j]表示第i块墙采取增加j的方案，所需要的最小cost，其中j的范围是0,1,2.因为第i块墙采取j方案之后，其高度就确定是h[i]+j了，那么需要保证第i-1块墙的最终方案不和它相冲突。而前一块墙的高度也就只有三种方案：h[i-1]+0, h[i-1]+1, h[i-1]+2，其对应的cost分别是dp[i-1][0],dp[i-1][1],dp[i-1][2]，只要在这里面挑选不与第i块墙冲突、且代价最小的方案，就可以确定dp[i][j]。

此题在比赛过程中，通过cin读入数据的话会被卡时间。解决方案是：
```cpp
ios::sync_with_stdio(false);
cin.tie(nullptr);
```
