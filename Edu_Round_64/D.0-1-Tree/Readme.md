### D.0-1-Tree

此题是个很不错的题，将考察并查集的应用提升到了一个很高的层次，同时需要对“树”这种数据结构有敏感度。

我们比较容易想到通过0边或着通过1边将这些点“聚类”。但是聚类之后怎么数pair是个难题。但事实上，只要掌握了技巧就很容易找到突破口：那就是考察那些既和0边相连、也和1边相连的那些点。

对于一个点A，它可以通过若干条1边和很多点聚成一类X，这些点彼此之间都是通过1相连的，假设有M个。同理它可以通过若干条0边和很多点聚成一类Y，这些点彼此之间都是通过0相连的，假设有N个。同时我们知道，因为这个图形是一棵“树”，这意味着与A通过1边的聚类那(M-1)个点，和与A通过0边的聚类那(N-1)个点，一定是不会相连的。否则这个图就有了环，违反题意。

现在我们来看题意，要求的路径有三类：必须都是走1边，或者必须都是走0边，或者先走1边再走0边（而不能再经过1边）。此时我们考察，如果A是该条路径中走完所有1边的最后一个点，那么满足题意的路径的起始点pair总共有多少个呢？

因为起点必须是在X类中，所以有M个可能（包括A点本身）。而终点必须是A点（最后一个1边达到的点）或者Y类中（最后经过的都是0边），所以有N个可能。于是总共有M*N钟可能，再减去1（就是以A为起点以A为终点的情况，这不合法）。

所以我们只要遍历所有的点，把它想象成某条合法路径走完1边之后经过的最后一个点（当然之后可能会再走0边），那么就可以得到符合题意的起始点pair的数目。最后累加起来就是答案。注意，我们说可以遍历所有的点，不管该点有没有1边或者0边相连，都可以套用上面的思想，只不过对应的M或N就是1而已。

其他方面，这里的union find模板中，在unite环节需要添加一个对于size[findRoot(x)]的更新算式，记录这个聚类的节点个数，需要好好体会写法。
