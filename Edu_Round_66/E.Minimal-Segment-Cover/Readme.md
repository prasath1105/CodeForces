### E.Minimal-Segment-Cover

首先，我们要根据题目给出的```interval(start,end)```，可以构造```next[start]=end```表示从start可以通过同一个区间练到end。

那么如果给一个任意的start，怎么确定next[start]呢？首先我们定义，对于任何的x属于[0,MAX]，我们都有```next[x]=x```。然后我们可以想到，如果我们已知next[x-1]，那么其实有```next[x] = max(next[x-1], next[x])```.于是我们将x从0到MAX进行遍历，就可以得到所有的next[x]。

有了这样的next数组，对于任意的```query(l,r)```，我们都可以通过```l = next[l]```的方式不断迭代，直至```l>=r```结束，其中经历迭代的次数就是答案。

在本题中，这样的迭代过程太久的话，会超时。一个缩短时间的办法是构造```next[i][j]```，表示从i开始，跳过2^j个区间可以抵达的最远的端点。这里j的取值是[0,20]（因为从0开始，最多跳2^20个区间就一定能达到MAX了）。这样预处理之后，我们可以快速地定位一个合适的```j0```，一下子直接跳过了```2^j0```区间，然后再从```l=next[i][j0]```开始下一次探索。这样就极大地加快了迭代的速率。
