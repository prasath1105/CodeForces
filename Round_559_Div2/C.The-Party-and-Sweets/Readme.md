### C.The-Party-and-Sweets

这道题对逻辑推理的能力要求很高。

我们显然会把a和b都排个序。一个显而易见的要求就是```a[n-1]<=b[0]```，因为第n-1个男孩给每一个女生都至少发了a[n-1]个，而第0个女孩说自己最多只收到了b[0]<a[n-1]个，显然是矛盾的。

然后我们如何设计贪心的策略使得总的糖果数目最少呢？我们会想到最后一个男孩给每个女孩发的基本线是最高的，所以他至少发了a[n-1]\*m个，可见他是一个土豪。既然是土豪，发糖的基本线都那么高，那么就让他来对应那些收到单人糖果最多的女生们呗。因为他的基本线就高，所以相比于其他男生，相对再花更少的代价就可以满足那些较大的b[j].所以对于任何```b[j]>=a[n-1]```的女生j，我们都可以让她们对应于这个土豪男。一路从后往前遍历j，直至某个b[j]<a[n-1]，这个女生收到的最多的单人馈赠都少于土豪的基本线，那么她肯定不能对应给土豪，我们就考虑下一个男生。

所以基本的逻辑大概是：
```cpp
int j=m-1;
int result = 0;
for (int i=n-1; i>=0; i--)
{
    result+=m*a[i];
    while (j>=0 && a[i]<=b[j])
    {
    	result+=b[j]-a[i];
    	j--;
    }
}
```
当遍历完所有的男生后，仍有女生没有找到配对的（也就是j>=0），那么就说明无法实现。

以上的算法有一个漏洞。对于男女生这样的数据：
```
1 1 2
3 4
```
这种情况下，尽管2<3, 2<4，但土豪不能包揽所有的两个女生。因为土豪包揽这两个女生的话（即分别给她们3和4），土豪的基本线就不是2了。所以这种情况下土豪只能包揽第二个女生，而把第一个女生留给下一个男生。

所以我们在处理最大的土豪男生的时候，对于j的遍历有个限制，不能包揽所有的b[j]>=a[n-1]。当找到最后一个b[j]>=a[n-1]时，如果b[j]!=a[n-1]，我们就要吐回这个j留给下一个男生，而让a[n-1]的基本线要求可以被这个j满足。特别注意，对于其他男生，我们则都不需要做类似的处理：这是因为其他男生的基本线，都可以靠最后一个女生来满足，因为最后一个女生的最高单人接收额肯定是靠最后一个男生来给的。



