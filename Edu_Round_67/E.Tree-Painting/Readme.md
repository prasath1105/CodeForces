### E.Tree-Painting

我们想,假设第一个涂黑点就是节点1的话,之后的操作其实是已经固定的了!此时,我们可以想象节点1就是整棵树的root,涂黑root的得分就是root下面所有节点的个数(记为children[root]).然后我们我们可以递归处理root下面的每个子节点u,当它们各自被涂黑的时候,得分其实它们"下面"所有节点的个数children[u].然后一直这样递归下去.每个节点得分的总和total,就是以节点1为root时我们的最后得分.

这时,我们应该可以发现,只要将1,2,...,n分别尝试作为整棵树的root,将所有相应得到的total取最大值,就是我们的答案了.

那么我们真的要重复n次上述的操作吗?不用.假设节点1作为root时我们的得分为total,那么我们以节点2(它为节点1的一个邻接节点)作为root时,有什么简单的方法得到对应的total呢?我们可以这么想,当root从1转移到2时:原本涂黑节点1的得分,从n变成了n-children[2](砍掉了通往节点2的分支);原本图和节点2的得分,从原来chilren[2]变成了n.所以我们可以简单地得到,当节点2为root时,total更新为total-chilren[2]+(n-children[2]).我们可以依次类推,从节点1开始顺着路径扩展到其他的节点i,计算以节点i为root时对应的total[i].最终的答案就是最大的那个total[i].

本题的dfs代码有一个比较漂亮的写法,就是定义为```dfs(int x, int father)```.这样我们在从节点x向它的临界节点扩散时,就避免了再返回到它的father.从树的角度上看,这种写法保证递归的方向就能保证一直是向下进行的.特别的,如果x是root的话,我们可以在调用dfs的时候人工定义father为一个虚拟的节点0,非常方便.
