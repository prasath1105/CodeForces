### D.Mysterious-Code

首先设计一个类似KMP算法中的next数组。比如字符串是code，模式串是s，那么next[i][c]表示：在匹配之前，s已经和code匹配对了前i个字符（这里考虑1-index）；此时如果code的下一个字符是c，那么s能够与code配对的字符数是多少。这里主要分两种情况：如果s的第i+1个字符也是c（也就是说和code的下一个字符匹配）或者c就是通配符星号，那么```next[i][c]=i+1```.显然，考虑完这个c之后，s与code能匹配的字符数应该就是自加1.

第二种情况，就是s的第i+1个字符不能与c匹配。此时为了能匹配c，对于模式串s的指针必须回退。一个最优的回退肯定不是直接回到s的起点，而是试图找到最大的位置j，使得```s[1:j-1] == s[i-j:i]```且```s[j]==c```.这样的目的是使得```s[i-j:i]```这段能够重复利用。如果能找到这样的j，那么next[i][c]就等于这样的j；否则找不到的话，next[i][c]就等于0，也就是模式串的指针从头开始。

如果next[i][c]等于s串的最后一个字符，那么就说明code和s完整匹配了一次，相应的计数器加1.

所以我们对于s和t都需要提前计算好这样的```nextS[n][26]```和```nextT[m][26]```.注意，next数组的计算是不需要code字符串的参与的，因为第二个维度就是穷举了字符的可能性。我们可以看出，这样的next数组的计算就是很类似KMP算法的预处理的过程。

然后我们考虑总体的框架：dp[i][ks][kt]表示我们对于code[1:i]，我们对两个模式串分别已经匹配到了```s[1:ks]```和```t[1:kt]```的长度，此时的score。我们试图通过```dp[i][ks][kt]```来更新任何可能的```dp[i+1][ns][nt]```.其中ns就是s在考虑了```c=code[i+1]```之后下一步能匹配的长度；其中nt就是t在考虑了```c=code[i+1]```之后下一步能匹配的长度。这些分别就是```ns = nextS[ks][c], nt = nextT[kt][c]```.如果ns或者nt有到达s或者t的末尾的话，那么dp[i+1][ns][nt]就要做相应的增减。
```cpp
    for (int i = 0; i < k; i++)
        for (int ks = 0; ks <= n; ks++)
            for (int kt = 0; kt <= m; kt++)
                for (char c = 'a'; c <= 'z'; c++)
                    if (code[i+1]=='*' || code[i+1]==c) 
                    {
                        int ns = nxt_s[ks][c-'a'];
                        int nt = nxt_t[kt][c-'a'];                        
                        dp[i+1][ns][nt] = max(dp[i+1][ns][nt], dp[i][ks][kt] + (ns==n) - (nt==m));
                    }
```                    

最终的答案就是考察dp[k][?][?]过程中出现的最大值。

