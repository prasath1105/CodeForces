### C.Hide-and-Seek

基本就是设计最优的策略。

我们统计每个位置会被哪几次call到，存储在q[i]里面。

我们遍历所有的位置i，考察有多少合理的pair是起始于i位置的。

如果q[i]为空，那么说明可以一直安心待在那里(+1)。也可以在最后一轮之后跳到这个它两边相邻的位置(+2)，当然如果i本身就在边缘，那就只能+1.

如果q[i]不为空，说明这个位置肯定会被call到，必须得跑。所以想从i跳到相邻的位置的话，必须在i被第一次call之前跑，而且跑到相邻的位置之后得保证在那里就不会再被call到。所以就是说q[i][0]要小于q[i-1]（或者q[i+1]）的最后一次call才行。
